# 洛谷-P1309 瑞士轮

> 原题链接：https://www.luogu.com.cn/problem/P1309

- [题目背景](#题目背景)
- [题目描述](#题目描述)
- [输入格式](#输入格式)
- [输出格式](#输出格式)
- [输入输出样例](#输入输出样例)
- [说明/提示](#说明/提示)
- [C++代码](#C++代码)

---

### <a name="题目背景">题目背景</a>

在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。

本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。

### <a name="题目描述">题目描述</a>

2×N 名编号为 $1\sim 2N$ 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。

每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1 名和第2 名、第 3 名和第 4名、……、第2K−1名和第2K 名、……  、第2N−1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得 0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。

现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第Q的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。

### <a name="输入格式">输入格式</a>

第一行是三个正整数N,R,Q,每两个数之间用一个空格隔开，表示有 $2 \times N$名选手、R 轮比赛，以及我们关心的名次 Q。

第二行是$2 \times N$ 个非负整数$s_1, s_2, …, s_{2N}$，每两个数之间用一个空格隔开，其中$s_i$表示编号为i 的选手的初始分数。 第三行是$2 \times$个正整数$w_1 , w_2 , …, w_{2N}$，每两个数之间用一个空格隔开，其中 $w_i$ 表示编号为i 的选手的实力值。

### <a name="输出格式">输出格式</a>

一个整数，即R 轮比赛结束后，排名第Q 的选手的编号。

### <a name="输入输出样例">输入输出样例</a>

#### 输入 #1

```c++
2 4 2 
7 6 6 7 
10 5 20 15 
```

#### 输出 #1

```c++
1
```

### <a name="说明/提示">说明/提示</a>

【样例解释】

![img](https://cdn.luogu.com.cn/upload/pic/98.png)

【数据范围】

对于30%的数据，1≤N≤100；

对于50%的数据，1≤N≤10,000；

对于100%的数据，$1 ≤ N ≤ 100,000,1 ≤ R ≤ 50,1 ≤ Q ≤ 2N,0 ≤ s_1, s_2, …, s_{2N}≤10^8,1 ≤w_1, w_2 , …, w_{2N}≤ 10^8$。

noip2011普及组第3题。

### <a name="C++代码">C++代码</a>

```c++
#include <iostream>
#include <algorithm>
using namespace std;

struct node {
    int id;
    int s;
    int w;
}player[200000],winner[100000],loser[100000];

bool cmp(node x, node y) {
    if(x.s!=y.s)
        return x.s>y.s;
    return x.id<y.id;
}

int main() {
    int n,r,q,i,j;
    cin>>n>>r>>q;
    for(i=0;i<2*n;++i) {
        player[i].id=i+1;
        cin>>player[i].s;
    }
    for(i=0;i<2*n;++i)
        cin>>player[i].w;
    sort(player,player+2*n,cmp);
    for(i=0;i<r;++i) {
        for(j=0;j<n;++j)
            if(player[2*j].w>player[2*j+1].w) {
                ++player[2*j].s;
                winner[j]=player[2*j];
                loser[j]=player[2*j+1];
            }
            else {
                ++player[2*j+1].s;
                winner[j]=player[2*j+1];
                loser[j]=player[2*j];
            }
        merge(winner,winner+n,loser,loser+n,player,cmp);
    }
    cout<<player[q-1].id<<endl;
    return 0;
}
```