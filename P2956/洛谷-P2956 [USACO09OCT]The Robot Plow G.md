# 洛谷-P2956 [USACO09OCT]The Robot Plow G

> 原题链接：https://www.luogu.com.cn/problem/P2956

- [题目描述](#题目描述)
- [输入格式](#输入格式)
- [输出格式](#输出格式)
- [输入输出样例](#输入输出样例)
- [说明/提示](#说明/提示)
- [C++代码](#C++代码)

---

### <a name="题目描述">题目描述</a>

Farmer John为了让自己从无穷无尽的犁田工作中解放出来，于是买了个新机器人帮助他犁田。这个机器人可以完成犁田的任务，可惜有一个小小的缺点：这个犁田机器人一次只能犁一个边的长度是整数的长方形的田地。

因为FJ的田地有树和其它障碍物，所以FJ设定机器人去犁很多不同的长方形。这些长方形允许重叠。他给机器人下了P个指令，每个指令包含一个要犁长方形的地。这片田地由长方形的左下角和右上角坐标决定。他很好奇最后到底有多少个方格的地被犁过了。

一般来说，田地被分割为很多小方格。这些方格的边和x轴或y轴平行。田地的宽度为X个方格，高度为Y个方格 (1 <= X <=  240; 1 <= Y <= 240). FJ执行了I (1 <= I <=  200)个指令，每个指令包含4个整数：Xll, Yll, Xur, Yur (1 <= Xll <= Xur; Xll <=  Xur <=X; 1 <= Yll <= Yur; Yll <= Yur <= Y),  分别是要犁的长方形的左下角坐标和右上角坐标。机器人会犁所有的横坐标在Xll..Xur并且纵坐标在Yll..Yur范围内的所有方格的地。可能这个长方形会比你想象的多一行一列（就是说从第Xll列到第Xur列一共有Xur - Xll + 1列而不是Xur - Xll列）。

考虑一个6方格宽4方格高的田地。FJ进行了2个操作（如下），田地就被犁成"*"和"#"了。虽然一般被犁过的地看起来都是一样的。但是标成"#"可以更清晰地看出最近一次被犁的长方形。

```cpp
......             **....             #####. 
......  (1,1)(2,4) **....  (1,3)(5,4) #####. 
......             **....             **.... 
......             **....             **.... 
```

一共14个方格的地被犁过了。

### <a name="输入格式">输入格式</a>

- 第1行：三个以空格分隔的整数：X，Y和I
- 第2..I + 1行：第i + 1行包含耕作指令i，该指令由四个整数描述：Xll，Yll，Xur和Yur

### <a name="输出格式">输出格式</a>

- 第1行：一个整数，代表所耕制的正方形总数

### <a name="输入输出样例">输入输出样例</a>

#### 输入 #1

```c++
6 4 2 
1 1 2 4 
1 3 5 4 
```

#### 输出 #1

```c++
14 
```

### <a name="说明/提示">说明/提示</a>

As in the task's example.

### <a name="C++代码">C++代码</a>

```c++
#include <iostream>
using namespace std;

int a[250][250];

int main() {
    int x, y, t, ans=0;
    cin >> x >> y >> t;
    int xi[t], yi[t], xu[t], yu[t];
    for (int i=0; i<t; ++i)
        cin >> xi[i] >> yi[i] >> xu[i] >> yu[i];
    for (int i=0; i<t; ++i)
        for (int j=xi[i]; j<=xu[i]; ++j)
            for (int k=yi[i]; k<=yu[i]; ++k)
                a[y-k+1][j] = 1;
    for (int i=1; i<=y; ++i)
        for (int j=1; j<=x; ++j)
            if (a[i][j] == 1)
                ++ans;
    cout << ans << endl;
    return 0;
}
```