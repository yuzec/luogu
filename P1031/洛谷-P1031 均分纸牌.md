# 洛谷-P1031 均分纸牌

> 原题链接：https://www.luogu.com.cn/problem/P1031

- [题目描述](#题目描述)
- [输入格式](#输入格式)
- [输出格式](#输出格式)
- [输入输出样例](#输入输出样例)
- [C++代码](#C++代码)

---

### <a name="题目描述">题目描述</a>

有N堆纸牌，编号分别为 1,2,…,N。每堆上有若干张，但纸牌总数必为N的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为1堆上取的纸牌，只能移到编号为222的堆上；在编号为N的堆上取的纸牌，只能移到编号为N−1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如N=4，4堆纸牌数分别为：

①9②8③17④6

移动3次可达到目的：

从 ③ 取4张牌放到 ④ （9,8,13,10）-> 从 ③ 取3张牌放到 ②（9,11,10,10）-> 从 ② 取1张牌放到①（10,10,10,10）。

### <a name="输入格式">输入格式</a>

两行

第一行为：N（N 堆纸牌，1≤N≤100）

第二行为：$A_1,A_2,…,A_n$ （N堆纸牌，每堆纸牌初始数，1≤$A_i$≤10000）

### <a name="输出格式">输出格式</a>

一行：即所有堆均达到相等时的最少移动次数。

### <a name="输入输出样例">输入输出样例</a>

#### 输入 #1

```c++
4
9 8 17 6
```

#### 输出 #1

```c++
3
```

### <a name="C++代码">C++代码</a>

```c++
#include <iostream>
using namespace std;

int main() {
    int n,i,j,k,num,sum=0,ans=0;
    cin>>n;
    int a[n];
    for(i=0;i<n;++i)
        cin>>a[i];
    for(i=0;i<n;++i)
        sum+=a[i];
    num=sum/n;
    for(i=0;i<n;i=j) {
        sum=0;
        for(j=i;j<n&&sum<=num*(j-i);++j)
            sum+=a[j];
        sum-=num*(j-i);
        if(sum!=0) {
            a[j-1]-=sum;
            a[j]+=sum;
            ++ans;
        }
        for(k=j-1;k>i;--k)
            if(a[k]>num) {
                a[k-1]+=a[k]-num;
                a[k]=num;
                ++ans;
            }
    }
    cout<<ans<<endl;
    return 0;
}
```