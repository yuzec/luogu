# 洛谷-P1320 压缩技术（续集版）

> 原题链接：https://www.luogu.com.cn/problem/P1320

- [题目描述](#题目描述)
- [输入格式](#输入格式)
- [输出格式](#输出格式)
- [输入输出样例](#输入输出样例)
- [C++代码](#C++代码)

---

### <a name="题目描述">题目描述</a>

设某汉字由N X  N的0和1的点阵图案组成，如下图。我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从上到下，由左到右。第一个数表示连续有几个0，第二个数表示接下来连续有几个1，第三个数再接下来连续有几个0，第四个数接着连续几个1，以此类推。。。

例如: 以下汉字点阵图案：

0001000

0001000

0001111

0001000

0001000

0001000

1111111

对应的压缩码是： 7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 （第一个数是N ,其余各位表示交替表示0和1 的个数，压缩码保证 N X N=交替的各位数之和）

### <a name="输入格式">输入格式</a>

汉字点阵图（点阵符号之间不留空格）。（3<=N<=200）

### <a name="输出格式">输出格式</a>

一行，压缩码。

### <a name="输入输出样例">输入输出样例</a>

#### 输入 #1

```c++
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

#### 输出 #1

```c++
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7
```

### <a name="C++代码">C++代码</a>

```c++
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    string s[200];
    cin >> s[0];
    int len = s[0].length();
    for (int i=1; i<len; ++i)
        cin >> s[i];
    int a[len*len], b[len*len];
    int flag=0, count=0, k=0;
    for (int i=0; i<len; ++i)
        for (int j=0; j<len; ++j)
            if (s[i][j]-'0' == flag)
                ++count;
            else {
                b[k++] = count;
                count = 1;
                flag = !flag;
            }
    b[k++] = count;
    cout << len;
    for (int i=0; i<k; ++i)
        cout << ' ' << b[i];
    cout << endl;
    return 0;
}
```