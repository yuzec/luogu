# 洛谷-P1319 压缩技术

> 原题链接：https://www.luogu.com.cn/problem/P1319

- [题目描述](#题目描述)
- [输入格式](#输入格式)
- [输出格式](#输出格式)
- [输入输出样例](#输入输出样例)
- [C++代码](#C++代码)

---

### <a name="题目描述">题目描述</a>

设某汉字由N × N的0和1的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个0，第二个数表示接下来连续有几个1，第三个数再接下来连续有几个0，第四个数接着连续几个1，以此类推……

例如: 以下汉字点阵图案：

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

对应的压缩码是： 7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 （第一个数是N ,其余各位表示交替表示0和1 的个数，压缩码保证 N × N=交替的各位数之和）

### <a name="输入格式">输入格式</a>

一行，压缩码。

### <a name="输出格式">输出格式</a>

汉字点阵图（点阵符号之间不留空格）。（3<=N<=200）

### <a name="输入输出样例">输入输出样例</a>

#### 输入 #1

```c++
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7
```

#### 输出 #1

```c++
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

### <a name="C++代码">C++代码</a>

```c++
#include <iostream>
using namespace std;

int main() {
    int n, k=0, m=0, flag=1;
    cin >> n;
    int a[n*n], b[n*n];
    for (int sum=0; sum < n*n; ++k) {
        cin >> a[k];
        sum += a[k];
    }
    for (int i=0; i<k; ++i) {
        flag = !flag;
        for (int j=0; j<a[i]; ++j)
            b[m++] = flag;
    }
    for (int i=0; i<n*n; ++i) {
        if (i != 0 && i%n == 0)
            cout << '\n';
        cout << b[i];
    }
    cout << endl;
    return 0;
}
```